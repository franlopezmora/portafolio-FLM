---
title: "Diseñando el Backend de un Sistema de Pruebas de Manejo"
date: "09-02-2025"
description: "Un relato sobre la construcción de una arquitectura de microservicios para gestionar pruebas de manejo, desde las decisiones de diseño hasta el trabajo en equipo."
---

Hace unos meses arrancamos con un desafío ambicioso: construir, como parte del **Trabajo Práctico Integrador** de Backend, un sistema completo para gestionar **pruebas de manejo**. No queríamos quedarnos en lo académico; queríamos acercarnos a la realidad de una aplicación moderna, con microservicios, bases de datos reales y despliegues en contenedores. En este ensayo voy a contarte las decisiones que tomamos y cómo las implementamos.

## Arquitectura

Desde el principio optamos por una **arquitectura de microservicios**, porque nos permitía dividir el dominio en piezas independientes y trabajar de manera paralela. Terminamos con seis servicios principales:

- **tpi-admin-service (8081)**: centraliza la gestión de empleados, interesados, pruebas y zonas peligrosas.
- **tpi-vehiculos-service (8082)**: administra vehículos y sus relaciones.
- **tpi-reportes-service (8083)**: genera reportes y estadísticas a partir de la información acumulada.
- **tpi-notificaciones-service (8084)**: envía notificaciones a través de un webhook de Discord, lo que nos permitió tener feedback inmediato cuando se registraba una prueba.
- **tpi-pruebas-service (8085)**: maneja toda la lógica específica de las pruebas de manejo.
- **tpi-gateway-service (8080)**: actúa como **API Gateway** y punto de entrada único, enrutando las solicitudes al microservicio correspondiente.

Esta división nos obligó a pensar en los contratos entre servicios y a utilizar **Spring Cloud Gateway** para centralizar la autenticación y el enrutamiento. Cada microservicio tiene su propia base de datos, lo que simplifica la consistencia interna y reduce acoplamientos.

import EssayImage from "../components/EssayImage.jsx";

<EssayImage
  src="Captura de pantalla 2025-09-07 185845.png"
  alt="Arquitectura del sistema de microservicios"
  bleed
/>

## Tecnologías

Elegimos **Java 21** como lenguaje base y **Spring Boot 3.3.5** como framework, aprovechando su soporte para microservicios y la madurez de su ecosistema. Para la persistencia usamos **Spring Data JPA** y **PostgreSQL** como base de datos principal, mientras que **H2** nos sirvió para testear en memoria. Para el cliente HTTP declarativo utilizamos **OpenFeign** y documentamos cada API con **SpringDoc OpenAPI**. La construcción y gestión de dependencias se resolvieron con **Maven**.

Aunque nuestro foco era el backend, también había un frontend en **Next.js 15.4.3** con **React 19.1.0** y **TailwindCSS 4**, lo que nos permitió probar los endpoints de manera interactiva. A nivel DevOps nos apoyamos en **Docker** y **Docker Compose** para orquestar todos los servicios.

## Persistencia

Optamos por **PostgreSQL 15** como motor de base de datos y empaquetamos su inicialización en un script ubicado en `/docker/db/init.sql`. Cada microservicio se conecta a su propia instancia, con usuarios y contraseñas definidos como variables de entorno por defecto (`postgres/postgres`). Para las pruebas automatizadas utilizamos **H2** porque facilita la ejecución de tests en memoria sin depender de un contenedor externo. La comunicación entre microservicios se realiza via HTTP REST y, cuando fue necesario, utilizamos Feign para simplificar llamadas internas.

## API Gateway

El **API Gateway** no es solo un router; también nos permitió concentrar políticas comunes como el manejo de errores, la documentación y los puntos de control. Exponemos todos los endpoints a través del puerto **8080**, y cada microservicio mantiene su URL interna. También configuramos **Spring Cloud Gateway** para exponer la documentación Swagger en un único punto (`/swagger-ui.html`).

## Notificaciones y Discord

Una de las particularidades del proyecto fue el servicio de notificaciones. En lugar de enviar correos tradicionales, decidimos integrar un **webhook de Discord**: cada vez que se crea una nueva prueba o se registra un interesado, se dispara un mensaje en un canal que utilizamos para seguimiento. Para configurarlo, basta con cambiar la URL del webhook en el archivo de configuración del microservicio.

## Scripts y despliegue

Queríamos que el entorno de desarrollo fuera lo más simple posible. Por eso escribimos un script `build-all.sh` que compila todos los microservicios, construye las imágenes y levanta todo el stack con `docker-compose up --build`. También preparamos instrucciones para ejecutar los servicios manualmente con Maven y levantar la base de datos por separado. Para reiniciar desde cero, basta con ejecutar `docker-compose down -v` y volver a correr el script de build.

Pensamos en el despliegue productivo y dejamos pautas claras: configurar variables de entorno específicas, usar una base de datos externa, montar un reverse proxy con SSL y habilitar monitoreo y logging. Todo esto quedó documentado para que cualquiera pueda replicar o mejorar el proyecto.

<EssayImage
  src="Captura de pantalla 2025-09-07 192111.png"
  alt="Proceso de desarrollo y despliegue del sistema TPI"
  bleed
/>

## Testing y calidad

Cada microservicio incluye tests unitarios y de integración. Establecimos un estándar: ninguna feature se mergea sin sus tests correspondientes. Con `mvn test` se ejecutan todos los tests de un servicio o del proyecto completo, lo que nos dio confianza para refactorizar sin miedo.

<div className="flex gap-4 mb-6">
  <EssayImage
    src="Captura de pantalla 2025-09-07 194705.png"
    alt="Tests unitarios del sistema TPI"
    className="flex-1"
  />
  <EssayImage
    src="Captura de pantalla 2025-09-07 194731.png"
    alt="Reportes y estadísticas del sistema TPI"
    className="flex-1"
  />
</div>

## Equipo y aprendizajes

Nada de esto hubiera sido posible sin el equipo. Trabajé junto a **Nicolás Garay**, **Mariano Iturriza** y **Marcos Belli**, y cada uno tomó ownership de un microservicio diferente. Esto nos permitió avanzar en paralelo y luego integrar en el gateway. Nos enfrentamos a problemas reales: sincronizar esquemas de base de datos, definir contratos de API, manejar errores asincrónicos y organizar nuestro repositorio para que fuese fácil de navegar.

## Lo que se viene

Aunque cumplimos con los requisitos académicos, el proyecto tiene mucho potencial. Nos gustaría añadir autenticación y autorización con JWT, refinar el sistema de notificaciones para que sea configurable (correo, SMS, Discord), y desplegarlo en una plataforma en la nube para probar su escalabilidad. También estamos considerando agregar monitoreo con Prometheus y Grafana y automatizar los despliegues con CI/CD.

## Cierre

Construir el backend de este sistema de pruebas de manejo fue más que una tarea universitaria; fue una inmersión en el diseño de sistemas modernos. Dividir el dominio en microservicios nos obligó a comunicarnos y a documentar cada decisión. Los contenedores, los scripts de despliegue y las pruebas nos enseñaron a pensar en la confiabilidad desde el primer día. Más importante aún, trabajar en equipo nos mostró que el código es la excusa para aprender a colaborar. Y aunque el proyecto ya funciona, sabemos que todavía queda mucho por explorar y mejorar.

